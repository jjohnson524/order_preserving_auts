#  this code is meant to compute the action of a monodromy generated by 2g+2 Dehn twists on a once punctured genus g surface
# the details are in the write up
# Neil R Hoffman and Hannah Turner
# blah blah 
#
# however they are also consistent with the monodromy action 
# described by Mark Bell here: https://knotinfo.math.indiana.edu/descriptions/monodromy.html
#
#
# this was written in python 3 on April 18 2021 
# while it is a companion to sage and can be run in sage for full functionality, however the code can take a monodromy word produce a 
# presentation for the fundamental group of a fibered knot and the n-fold branched cover of a fibered knot without being run in sage


### TODO: extend to the once punctured genus 1 case
### TODO1: consider adding S_g and S_g-2 as part of the generating set and describe the action on via the dehn twists
###         this would probably lead to shorter relations produced at the end of the computation
### TODO2: Perhaps extend to n punctured genus g surfaces
### TODO3: what happens for Bell's monodromy if 2g+2 > 26 (g > 12) 

# the generating set is stored as a set of generators
# each generator is a list. 
# the functions we can call on a generating set are
# __init__
# 
# simple_monodromy(data) if data is a letter we associate it to a simple Dehn twist lower case letters are postive Dehn twists and upper case are negative
#  if data is a number we associate it to the appropriate Dehn twist and the sign of the number records if the twist is postive or negative
#  note because of this, we start indexing the dehn twists at 1 not 0
#  also the first 2g-1 Dehn twists are standard the last 3 take special care
#  this is all explained in the Hoffman-Turner write up listed above
#
# if extending these methods to general punctured surfaces __init__ would need a punctures or genus flag

SAMPLE_INT = 0

# TODO add a clean up function
# add a ploynomial operator
# add a robust polynomial (that allows for conjugation and reordering terms)
def dehn_twist_index(twist):
    the_string = "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ"
    if the_string.find(twist) == -1:
        return None
    elif the_string.index(twist) % 2 == 0:
        return int(the_string.index(twist)/2)+1
    else:
        return int((-the_string.index(twist)-1)/2)


# right now this deals with 2g generators later we will add Sg and Sg-2 as generators

class generating_set:
    def __init__(self, number_gens, inv=False):
        if number_gens % 2 == 1:
           print("Currently only works for once punctued genus g surface")
        else:
           if inv:
               self.gens = [[[x, -1]] for x in range(1, number_gens+1)]  # later add two more generators S_g-2 and S_g
           else:
               self.gens = [[[x, 1]] for x in range(1, number_gens+1)]  # later add two more generators S_g-2 and S_g


        self.num_gens = number_gens
        self.the_genus =  int(self.num_gens/2)  # if number of generators changes make this self.num_gens/2-1

        self.original_gens = [y for y in self.gens]

        self.Sg = []

        for i in range(self.get_genus()-1): # first add \gamma_2g-3^(-1) \gamma_2g-5 ^(-1) ...\gamma_3^-1
            
           self.Sg.append([2*self.get_genus()-(2*i+1),-1])
           # then add [\gamma_1^-1,\gamma_2^-1]
        self.Sg.append([1,-1])
        self.Sg.append([2,-1])
        self.Sg.append([1,1])
        self.Sg.append([2,1])
        for i in range(2, self.get_genus()+1):
            self.Sg.append([2*i,-1])
            self.Sg.append([2*i-1,1])
            self.Sg.append([2*i,1])
             #self.Sg.append([2*i-1,-1])
             #self.Sg.append([2*i-1,1]) # these cancel


        self.SgM2 = []
           #print("need to fix this")
        for i in range(0, self.get_genus() - 3): # first add \gamma_2g-3^(-1) \gamma_2g-5 ^(-1) ...\gamma_3^-1
            self.SgM2.append([2*self.get_genus()-4-(2*i+1),-1])
            # then add [\gamma_1^-1,\gamma_2^-1]
        self.SgM2.append([1,-1])
        self.SgM2.append([2,-1])
        self.SgM2.append([1,1])
        self.SgM2.append([2,1])
        for i in range(2, self.get_genus()-1):
             self.SgM2.append([2*i,-1])
             self.SgM2.append([2*i-1,1])
             self.SgM2.append([2*i,1])
             #self.SgM2.append([2*i-1,-1])
             #self.SgM2.append([2*i-1,1]) # these cancel

    def __str__(self):
        return str(self.gens)

    def detail(self, label=None, for_sage = False):
        if label == None:
            data_string = "g="+str(self.get_genus()) + " original gens ="+str(self.original_gens) + " current state = "+str(self.get_gens())
        elif for_sage: # we knock down the indicies 
            data_string = "g="+str(self.get_genus()) + " original gens =["
            for g in range(len(self.original_gens)-1):
                data_string = data_string + label +str(g) +"," 
            data_string = data_string + label +str(len(self.original_gens)-1)+"]"

            data_string = data_string +" current state = ["
            for g in self.gens:

                for i in g:
                    data_string = data_string + label +"." + str(i[0]-1)+ "^" + str(i[1])+"*" 
                data_string = data_string[:-1]+","
            data_string = data_string[:-1]+"]"
        else:
            data_string = "g="+str(self.get_genus()) + " original gens =["
            for g in range(len(self.original_gens)-1):
                data_string = data_string + label +str(g+1) +"," 
            data_string = data_string + label +str(len(self.original_gens))+"]"

            data_string = data_string +" current state = ["
            for g in self.gens:

                for i in g:
                    data_string = data_string + label +"." + str(i[0])+ "^" + str(i[1])+"*" 
                data_string = data_string[:-1]+","
            data_string = data_string[:-1]+"]"

        return data_string

    def get_gens(self):
        return self.gens

    def get_num_gens(self):
        return self.num_gens

    def get_genus(self):
        return self.the_genus
    """
    def Sg(self):
        return self._Sg

    def SgM2(self):
        return self.SgM2
    """
    # cyclically reduces generators
    # returns nothing

    def reduce_gens(self):
        for j in range(len(self.gens)):
            g = self.gens[j]
            #prev_term = g[0]
            reduced_g = [g[0]]
            prev_index = 0
            for i in range(1, len(g)):
                #print(i, ' reduced_g', reduced_g, ' prev_index ', prev_index)
                if len(reduced_g) == 0:
                    reduced_g = [g[i]]
                    prev_index = 0
					
                elif g[i][0] == g[prev_index][0] and g[i][1] == -1*g[prev_index][1]:
                    if prev_index >-1:
                        cut_me = reduced_g[prev_index]
                        reduced_g.remove(cut_me)
                        #reduced_g.remove(reduced_g[prev_index])
                        prev_index = prev_index -1
                elif g[i][0] == g[prev_index][0]:
                    reduced_g[prev_index][1] =  g[i][1] + reduced_g[prev_index][1]
                else:
                    prev_index = prev_index+1
                    reduced_g.append(g[i])
            self.gens[j] = [x for x in reduced_g]    
				
				
    def hom_data(self, label, in_sage = False):
        if not in_sage:
            data_string  = ""
            for g in self.gens:
            
                for i in g:
                    data_string = data_string + label +"." + str(i[0]-1)+ "^" + str(i[1])+"*"
                    data_string = data_string[:-1]+","
                data_string = data_string[:-1]+"]"
            return data_string
        else:
            # make sure gap is running
            F = FreeGroup(self.num_gens)
            print("TODO")


    def simple_dehn_twist_num_index(self, index, verbose=False):
        for yIndex in range(len(self.gens)):
            y = self.gens[yIndex]
            newY = []
            for simpleElement in y:
                basicGen = simpleElement[0]
                genPower = simpleElement[1]

                if abs(index) < 2*self.get_genus() and index % 2 ==1 and basicGen == abs(index)+1:  # \ell_2i-1 ( \gamma_2i) = \gamma_2i-1 \gamma_2i 
                    if verbose:
                        print("abs(index) < 2*self.get_genus() and index % 2 ==1 and basicGen == abs(index)+1:")
                    if index > 0 and genPower > 0:
                        for power in range(genPower):
                            newY.append([basicGen-1,1]) # this has the effect of replacing [basicGen, genPower] with ([basicGen-1,1], [basicGen-1,1])^genPower
                            newY.append([basicGen,1])

                    elif index > 0 and genPower < 0:
                        for power in range(-genPower):
                            newY.append([basicGen,-1]) # this has the effect of replacing [basicGen, -n] with ([basicGen,1], [basicGen-1,1])^n
                            newY.append([basicGen-1,-1])

                    elif index < 0 and genPower > 0:
                        for power in range(genPower):
                            newY.append([basicGen-1,-1]) # this has the effect of replacing [basicGen, genPower] with ([basicGen-1,-1], [basicGen,1])^genPower
                            newY.append([basicGen,1])

                    elif index < 0 and genPower < 0:
                        for power in range(-genPower):
                            newY.append([basicGen,-1]) # this has the effect of replacing [basicGen, -n] with ([basicGen,-1], [basicGen-1,1])^n
                            newY.append([basicGen-1,1])

            # note here the max abs(index) can be is 2g-2 so there is always a index+2 element
            # also basicGen + 1 < 2g-2 so there is always basicGen +3 element
                elif abs(index) < 2*self.get_genus() and index % 2 ==0 and basicGen+1 == abs(index):  # \ell_2k ( \gamma_2k -1) = \gamma_2k -1 \gamma_2k (\gamma_2k)^-1  
                    if verbose:
                        print("abs(index) < 2*self.get_genus() and index % 2 ==0 and basicGen+1 == abs(index):")
                    if index > 0 and genPower > 0:
                        for power in range(genPower):
                            newY.append([basicGen,1]) 
                            newY.append([basicGen+3,1])
                            newY.append([basicGen+1,-1])

                    elif index > 0 and genPower < 0:
                        for power in range(-genPower):
                            newY.append([basicGen+1,1]) 
                            newY.append([basicGen+3,-1]) 
                            newY.append([basicGen,-1])

                    elif index < 0 and genPower > 0:
                        for power in range(genPower):
                            newY.append([basicGen,1]) 
                            newY.append([basicGen+1,1]) 
                            newY.append([basicGen+3,-1])

                    elif index < 0 and genPower < 0:
                        for power in range(-genPower):
                            newY.append([basicGen+3,1]) 
                            newY.append([basicGen+1,-1]) 
                            newY.append([basicGen,-1])

                # note here the max abs(index) can be is 2g-2 so there is always a index+1 element
                # also basicGen - 1 < 2g-2 so there is always basicGen +1 element
                elif abs(index) < 2*self.get_genus() and index % 2 ==0 and basicGen-1 == abs(index):  # \ell_2k ( \gamma_2k +1) = \gamma_2k  \gamma_2k+2^(-1) (\gamma_2k+1)^-1  
                    if index > 0 and genPower > 0:
                        for power in range(genPower):
                            newY.append([basicGen-1,1]) 
                            newY.append([basicGen+1,-1]) 
                            newY.append([basicGen,1])

                    elif index > 0 and genPower < 0:
                        for power in range(-genPower):
                            newY.append([basicGen,-1]) 
                            newY.append([basicGen+1,1]) 
                            newY.append([basicGen-1,-1])

                    elif index < 0 and genPower > 0:
                        for power in range(genPower):
                           newY.append([basicGen+1,1]) 
                           newY.append([basicGen-1,-1])
                           newY.append([basicGen,1]) 
                           

                    elif index < 0 and genPower < 0:
                        for power in range(-genPower):
                            newY.append([basicGen,-1])
                            newY.append([basicGen-1,1]) 
                            newY.append([basicGen+1,-1]) 
                            
                elif abs(index) == 2*self.get_genus() and basicGen == 2*self.get_genus()-1:  # ell_2g ( \gamma_2g -1) = \gamma_2g-1  \gamma_2g^(-1) 
                    if index > 0 and genPower > 0:
                        for power in range(genPower):
                            newY.append([basicGen,1]) 
                            newY.append([basicGen+1,-1]) 

                    elif index > 0 and genPower < 0:
                        for power in range(-genPower):
                            newY.append([basicGen+1,1]) 
                            newY.append([basicGen,-1]) 


                    elif index < 0 and genPower > 0:
                        for power in range(genPower):
                            newY.append([basicGen,1]) 
                            newY.append([basicGen+1,1]) 


                    elif index < 0 and genPower < 0:
                        for power in range(-genPower):
                            newY.append([basicGen+1,-1]) 
                            newY.append([basicGen,-1]) 


                elif abs(index) == 2*self.get_genus()+1 and basicGen == 2*self.get_genus()-1: # and index % 2 ==0 and basicGen-1 == abs(index):  
                    if index > 0 and genPower > 0:

                        for power in range(genPower):
                            newY.append([basicGen,1]) 
                            for stuff in  self.Sg: # change this if we add Sg to the generating set
                                newY.append(stuff)
                            newY.append([basicGen+1,-1]) 


                    elif index > 0 and genPower < 0:
 
                        for power in range(-genPower):
                            newY.append([basicGen+1,1]) 
                            for stuff in  self.Sg[::-1]: # change this if we add Sg to the generating set
                                newY.append([stuff[0],-1*stuff[1]])
                            newY.append([basicGen,-1]) 




                    elif index < 0 and genPower > 0:
                        
                        for power in range(genPower):
                             newY.append([basicGen,1]) 
                             newY.append([basicGen+1,1]) 
                             for stuff in self.Sg[::-1]: # change this if we add Sg to the generating set
                                 newY.append([stuff[0],-1*stuff[1]])



                    elif index < 0 and genPower < 0:

                        for power in range(-genPower):

                            for stuff in  self.Sg: # change this if we add Sg to the generating set
                                newY.append(stuff)
                            newY.append([basicGen+1,-1]) 
                            newY.append([basicGen,-1]) 




                elif abs(index) == 2*self.get_genus()+2 and basicGen == 2*self.get_genus()-3: # and index % 2 ==0 and basicGen-1 == abs(index):  # lamba_2k ( \gamma_2k +1) = \gamma_2k  \gamma_2k+2^(-1) (\gamma_2k+1)^-1  
                    if index > 0 and genPower > 0:

                        for power in range(genPower):
                            for stuff in  self.SgM2: # change this if we add SgM2 to the generating set
                                newY.append(stuff)
                            newY.append([basicGen+1,-1]) 
                            newY.append([basicGen,1]) 

                    elif index > 0 and genPower < 0:

                        for power in range(-genPower):
                            newY.append([basicGen,-1]) 
                            newY.append([basicGen+1,1]) 
                            for stuff in self.SgM2[::-1]: # change this if we add SgM2 to the generating set
                                newY.append([stuff[0],-1*stuff[1]])


                    elif index < 0 and genPower > 0:
                        
                        for power in range(genPower):
                            newY.append([basicGen+1,1]) 
                            for stuff in self.SgM2[::-1]: # change this if we add SgM2 to the generating set
                                newY.append([stuff[0],-1*stuff[1]])
                            newY.append([basicGen,1]) 


                    elif index < 0 and genPower < 0:

                        for power in range(-genPower):
                            newY.append([basicGen,-1]) 
                            for stuff in  self.SgM2: # change this if we add SgM2 to the generating set
                                newY.append(stuff)
                            newY.append([basicGen+1,-1]) 
                else: # none of the conditions hold

                    newY.append(simpleElement)

                if verbose:
                    print("index=",index, " basicGen = ",basicGen, "newY=", newY)
     
 
            
            self.gens[yIndex] = [x for x in newY]
            # else do nothing
                     


            # add tests A(a(\gamma_i^n)) = \gamma_i^n 
            # add a cleaner/greedy reduce
            # add gap_string(self)
            
            # add a knot group
    def monodromy_from_word(self, monodromy_word, verbose=False):
        for twist in monodromy_word[::-1]:
            self.simple_dehn_twist_num_index(dehn_twist_index(twist), verbose)
